\section{算法描述}

\begin{algorithm}
  \caption{快速排序算法}
  \begin{algorithmic}[1]
  \Procedure{QuickSort}{$array$}
    \State $n \gets \text{length of } array$
    \State $pivot \gets \text{random element of } array$
    \If {$n < 2$} \Return
    \EndIf
    \State $l \gets 0, r \gets n$
    \For {$i \gets 0 \text{ to } n-1$}
      \If {$array[i] < pivot$}
        \State $\text{swap } array[i] \text{ and } array[l]$
        \State $l \gets l + 1$
      \EndIf
    \EndFor
    \For {$i \gets n-1 \text{ to } 0$}
      \If {$array[i] > pivot$}
        \State $\text{swap } array[i] \text{ and } array[r - 1]$
        \State $r \gets r - 1$
      \EndIf
    \EndFor
    \State \Call{QuickSort}{$array[0..l]$}
    \State \Call{QuickSort}{$array[r..n]$}
  \EndProcedure
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{归并排序算法}
  \begin{algorithmic}[1]
  \Procedure{MergeSort}{$array$}
    \State $n \gets \text{length of } array$
    \If {$n < 2$} \Return
    \EndIf
    \State $m \gets n / 2$
    \State \Call{MergeSort}{$array[0..m]$}
    \State \Call{MergeSort}{$array[m..n]$}
    \State $i \gets 0, j \gets m, k \gets 0$
    \While {$i < m \wedge j < n$}
      \If {$array[i] < array[j]$}
        \State $result[k] \gets array[i]$
        \State $i \gets i + 1$
      \Else
        \State $result[k] \gets array[j]$
        \State $j \gets j + 1$
      \EndIf
      \State $k \gets k + 1$
    \EndWhile
    \While {$j < n$}
      \State $result[k] \gets array[j]$
      \State $j \gets j + 1$
      \State $k \gets k + 1$
    \EndWhile
    \While {$i < m$}
      \State $result[k] \gets array[i]$
      \State $i \gets i + 1$
      \State $k \gets k + 1$
    \EndWhile
    \For {$i \gets 0 \text{ to } n-1$}
      \State $array[i] \gets result[i]$
    \EndFor
  \EndProcedure
  \end{algorithmic}
\end{algorithm}
